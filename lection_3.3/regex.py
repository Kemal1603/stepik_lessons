# x = 'Hello, \n world'
# print(x)
# Вывод:
# Hello,
#  world


# x = r'Hello, \n world'
# print(x)

# Вывод:
# Hello, \n world

import re

# pattern = r'abc'
# string = 'accd'
# match = re.match(pattern, string)
# print(match)
# pattern = r'abc'
# string = 'babc'
# match = re.match(pattern, string)
# print(match)
# Выводом будет None так как метод  выше находит вхождение только того шаблона, который описан, то есть начитаться слово
# в строке должно именно с а


# А для того чтобы найти вхождение шаблона в строку независимо от того, где и как будет расположен шаблон, то есть даже,
# если в строке будет слово в котором, перед шаблоном будет стоять другая буква, он ее все равно найдет - метод search

# pattern = r'abc'
# string = 'babc'
# match = re.search(pattern, string)
# print(match)
'''Вывод:
<re.Match object; span=(1, 4), match='abc'>'''

# Если возникнет ситуация, в которой мы точно не будем знать, какоу именно искать шаблон, но к примеру мы знаем,первый и
# последний символ, а что является вторым символом мы лишь можем предположить, тут к нам приходят на помощь метасимволы:

# pattern = r'a[abc]c'
# string = 'babc'
# match = re.search(pattern, string)
# print(match)

'''Вывод будет такой же как и выше:
<re.Match object; span=(1, 4), match='abc'>'''
# А все потому что метасимвол [...] Используется для подставления указанным элементом один из ВОЗМОЖНЫХ вариантов, то есть
# если мы ищем в строке abcd, шаблон acd, но не помним точто какой второй символ, все предположения пишем в [bc] и тогда
# метод search найдет вхождение именно того шаблона, который нам нужен

'''Метасимволы и их описания:'''

# Оператор	        |           Описание
# .	       ...................Один любой символ, кроме новой строки \n.
# ?	       ...................0 или 1 вхождение шаблона слева
# +	       ...................1 и более вхождений шаблона слева
# *	       ...................0 и более вхождений шаблона слева
# \w	   ...................Любая цифра или буква (\W — все, кроме буквы или цифры)
# \d	   ...................Любая цифра [0-9] (\D — все, кроме цифры)
# \s	   ...................Любой пробельный символ [\t,\n,\r,\f,\v](\S — любой непробельный символ)
# \b	   ...................Граница слова
# [..]	   ...................Один из символов в скобках ([^..] — любой символ, кроме тех, что в скобках)
# \	       ...................Экранирование специальных символов (\. означает точку или \+ — знак «плюс»)
# ^ и $	   ...................Начало и конец строки соответственно
# {n,m}	   ...................От n до m вхождений ({,m} — от 0 до m)
# a|b	   ...................Соответствует a или b
# ()	   ...................Группирует выражение и возвращает найденный текст
# \t, \n, \r..................Символ табуляции, новой строки и возврата каретки соответственно


# pattern = r'a[abc]c'
# string = 'acc'
# match = re.search(pattern, string)
# print(match)

# string = 'abc, acc, aac'
# all_inslusions = re.findall(pattern, string)
# print(all_inslusions)

'''Вывод:
['abc', 'acc', 'aac']
Так как все, что мы искали при помощи метасимвола pattern = r'a[abc]c' подходит и присутствует в строке
string = 'abc, acc, aac', то метод findall выведет нам все вхождения, которые соответствуют нашему шаблону'''

# Если предыдущий метод findall только находит и выводит, то вот следующий метод sub заменяет все найденные соответствия
#  на указанное вторым аргументом значение то есть :
# fixed_typos = re.sub(pattern, 'abc', string)
# print(fixed_typos)

'''Выведет:
   abc, abc, abc'''
# Так как в нашей переменной string = 'abc, acc, aac' все 3 элемента подходят под критерий поиска нашего шаблона
# pattern = r'a[abc]c' и сразу при помощи метода  sub меняем все найденные соответствия на значения второго аргумента
# то есть: string = 'abc, acc, aac' --->string = 'abc, abc, abc'

# Так же, если промежуток вероятных символов в [...], которые мы изначально не знаем - большой и мы не хотим вводить
# все подряд, то мы можем воспользоваться " - " то есть последовательность от b до g не обязательно указывать так:
# bcdefg, вместо этого запишем вот так: pattern = r'a[b-g]c'

pattern = r'a[a-d]c'
string = 'acc'
match = re.search(pattern, string)
print(match)

string = 'abc, acc, aac, adc'
all_inslusions = re.findall(pattern, string)
print(all_inslusions)

fixed_typos = re.sub(pattern, 'abc', string)
print(fixed_typos)

'''Выведет:
<re.Match object; span=(0, 3), match='acc'>
['abc', 'acc', 'aac', 'adc']
abc, abc, abc, abc'''
