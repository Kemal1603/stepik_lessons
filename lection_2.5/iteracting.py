# n, k = map(int, input().split())
# print(n + k)

#  В примере выше показано, как работает функция map - она первым аргументом принимает функцию, а вторым аргументом
# принимает объект, по которому итерируется, то есть проходится по элементам в данном случае переводит все в целое число


# Следуюший пример наглядно показывает, как все работает поэтапно, если после запуска следующего кода мы введем 100 и 50
# то вывод будет следующий:
# 100 50 - это инпут
# ['100', '50'] - здесь мы выводим Х - показывается, что это список строк поделенный на 2 элемента при помощи split
# далее функция map(int, x) - переводит каждый строчный эелемент списка Х в инт при помощи встроенной функции int
# 150 - это результат работы кода, указанного ниже

# x = input().split()
# print(x)
# n, k = map(int, x)
# print(n + k)

# Так как у нас в примере есть итератор, то мы можем еще реализовать пример выше, следующим образом

# x = input().split()
# print(x)
# map_obj = map(int, x)
# print(map_obj)
# n = next(map_obj)
# k = next(map_obj)
# print(n + k)

#  Результатом работы кода будет:
# 100 50
# ['100', '50']
# <map object at 0x7fb10c4d9e20>
# 150


#  Однако мы можем использовать генератор (это как list comprehension, только с круглыми скобками ), но даже при этом
# случае, количество переменных должно быть равно количеству элементов, которые будут распаковываться из списка

# x = input().split()
# print(x)
# n, k = (int(i) for i in x)
# print(n + k)


x = input().split()
xs = (int(i) for i in x)


def even(s):
    return s % 2 == 0

#  Так как у нас функция xs - это генератор, то что бы вытянуть из генератора элементы и применить к каждому функцию
# необходимо использовать цикл for так как он под капотом будет использовать переменную events с вызовом метода next


evens = filter(even, xs)
for i in evens:
    print(i)
